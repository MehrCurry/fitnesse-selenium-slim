<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SeleniumElementFinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fitnesse-selenium-slim</a> &gt; <a href="index.source.html" class="el_package">com.github.andreptb.fitnesse.util</a> &gt; <span class="el_source">SeleniumElementFinder.java</span></div><h1>SeleniumElementFinder.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1"></span>
package com.github.andreptb.fitnesse.util;

import org.apache.commons.lang3.EnumUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Triple;
import org.openqa.selenium.By;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.github.andreptb.fitnesse.util.SeleniumElementFinderExpectedConditions.ElementDataExpectedCondition;

/**
 * Utility class to parse locators and find elements
 */
<span class="fc" id="L19">public class SeleniumElementFinder {</span>

	/**
	 * Locator selector typeIn separator constant
	 */
	private static final String SELECTOR_TYPE_SEPARATOR = &quot;=&quot;;
	/**
	 * Utility to process FitNesse markup so can be used by Selenium WebDriver
	 */
<span class="fc" id="L28">	private FitnesseMarkup fitnesseMarkup = new FitnesseMarkup();</span>

<span class="fc" id="L30">	private SeleniumElementFinderExpectedConditions expectedConditions = new SeleniumElementFinderExpectedConditions();</span>

	/**
	 * enum mapping selector identifier with selector implementation ({@link By} implementations).
	 */
<span class="fc" id="L35">	enum SelectorType {</span>
<span class="fc" id="L36">		id(By.ById.class),</span>
<span class="fc" id="L37">		name(By.ByName.class),</span>
<span class="fc" id="L38">		css(By.ByCssSelector.class),</span>
<span class="fc" id="L39">		xpath(By.ByXPath.class),</span>
<span class="fc" id="L40">		link(By.ByLinkText.class);</span>

		private Class&lt;? extends By&gt; byClass;

<span class="fc" id="L44">		SelectorType(Class&lt;? extends By&gt; byClass) {</span>
<span class="fc" id="L45">			this.byClass = byClass;</span>
<span class="fc" id="L46">		}</span>
	}

	/**
	 * Tries to selects element, waiting until is available. If locator is null, tries to return the current active (focused) element if there is one
	 *
	 * @see #waitUntilFind(WebDriver, int, ExpectedCondition)
	 * @param driver instance of {@link WebDriver}
	 * @param locator to be parsed
	 * @param timeoutInSeconds time to wait for element
	 * @return instance of {@link WebElement} found
	 * @throws TimeoutException if timeoutInSeconds is exceeded and nothing is found
	 */
	public WebElement find(WebDriver driver, String locator, int timeoutInSeconds) {
<span class="nc" id="L60">		return waitUntilFind(driver, timeoutInSeconds, this.expectedConditions.presenceOfElementLocated(parse(locator).getLeft()));</span>
	}

	/**
	 * Tries to selects element, waiting until is available. If locator is null, tries to return the current active (focused) element if there is one. This method will wait until
	 * desired element is ready to receive input, such as keyboard keys and clicks.
	 *
	 * @see #waitUntilFind(WebDriver, int, ExpectedCondition)
	 * @see SeleniumElementFinderExpectedConditions#presenceOfElementDisplayedAndEnabled(By)
	 * @param driver instance of {@link WebDriver}
	 * @param locator to be parsed
	 * @param timeoutInSeconds time to wait for element
	 * @return instance of {@link WebElement} found
	 * @throws TimeoutException if timeoutInSeconds is exceeded and nothing is found
	 */
	public WebElement findToInput(WebDriver driver, String locator, int timeoutInSeconds) {
<span class="fc" id="L76">		return waitUntilFind(driver, timeoutInSeconds, this.expectedConditions.presenceOfElementDisplayedAndEnabled(parse(locator).getLeft()));</span>
	}

	/**
	 * Tries to get an element's attribute, waiting until is available. If the element selector part of the locator is empty, tries to return the current active (focused) element if there is one
	 *
	 * @param driver instance of {@link WebDriver}
	 * @param locator to be parsed
	 * @param timeoutInSeconds time to wait for element
	 * @return attribute value
	 * @throws TimeoutException if timeoutInSeconds is exceeded and nothing is found
	 */
	public String findAttribute(WebDriver driver, String locator, int timeoutInSeconds) {
<span class="fc" id="L89">		Triple&lt;By, String, String&gt; parsedLocator = parse(locator);</span>
<span class="fc" id="L90">		return findWithExpectedResult(driver, timeoutInSeconds, this.expectedConditions.presenceOfElementAttributeLocated(parsedLocator.getLeft(), parsedLocator.getMiddle(), parsedLocator.getRight()));</span>
	}

	/**
	 * Returns if an element or an element's attribute with given locator is present or absent, depending of &lt;b&gt;ensurePresent&lt;/b&gt; argument.
	 *
	 * @param driver instance of {@link WebDriver}
	 * @param locator to be parsed
	 * @param timeoutInSeconds time to wait for element
	 * @param ensurePresent if &lt;code&gt;true&lt;/code&gt; checks if the element is present on the page. Otherwise checks if the element is absent of the page
	 * @return if an element or attribute with given locator is present on the page
	 */
	public boolean presentOrAbsent(WebDriver driver, String locator, int timeoutInSeconds, boolean ensurePresent) {
<span class="fc" id="L103">		Triple&lt;By, String, String&gt; parsedLocator = parse(locator);</span>
		try {
<span class="fc" id="L105">			return waitUntilFind(driver, timeoutInSeconds, this.expectedConditions.presenceOrAbsenceOfElementOrAttribute(parsedLocator.getLeft(), parsedLocator.getMiddle(), ensurePresent));</span>
<span class="fc" id="L106">		} catch (TimeoutException e) {</span>
<span class="fc" id="L107">			return false;</span>
		}
	}

	public String findText(WebDriver driver, String locator, int timeoutInSeconds) {
<span class="fc" id="L112">		Triple&lt;By, String, String&gt; parsedLocator = parse(locator);</span>
<span class="fc" id="L113">		return findWithExpectedResult(driver, timeoutInSeconds, this.expectedConditions.presenceOfElementText(parsedLocator.getLeft(), parsedLocator.getRight()));</span>
	}

	public String findValue(WebDriver driver, String locator, int timeoutInSeconds) {
<span class="fc" id="L117">		Triple&lt;By, String, String&gt; parsedLocator = parse(locator);</span>
<span class="fc" id="L118">		return findWithExpectedResult(driver, timeoutInSeconds, this.expectedConditions.presenceOfElementValue(parsedLocator.getLeft(), parsedLocator.getRight()));</span>
	}

	private String findWithExpectedResult(WebDriver driver, int timeoutInSeconds, ElementDataExpectedCondition condition) {
		try {
<span class="fc" id="L123">			return waitUntilFind(driver, timeoutInSeconds, condition);</span>
<span class="nc" id="L124">		} catch (TimeoutException e) {</span>
<span class="nc" id="L125">			condition.disableDataCheck();</span>
<span class="nc" id="L126">			return condition.apply(driver);</span>
		}
	}

	/**
	 * Tries to get the return from {@link ExpectedCondition} waiting until configured timeout time
	 *
	 * @param driver instance of {@link WebDriver}
	 * @param timeoutInSeconds time to wait for element
	 * @param condition instance of {@link ExpectedCondition}
	 * @param &lt;T&gt; return type of elementFound
	 * @return elementFound instance of whatever {@link ExpectedCondition} returned
	 * @throws TimeoutException if timeoutInSeconds is exceeded
	 */
	public &lt;T&gt; T waitUntilFind(WebDriver driver, int timeoutInSeconds, final ExpectedCondition&lt;T&gt; condition) {
<span class="fc" id="L141">		WebDriverWait wait = new WebDriverWait(driver, timeoutInSeconds);</span>
<span class="fc" id="L142">		return wait.until(condition);</span>
	}

	/**
	 * Parses locator to an instance of {@link Triple}, which by itself contains {@link By} instance and an optional attribute selector. Tries to emulate Selenium IDE searching methods:
	 * &lt;ul&gt;
	 * &lt;li&gt;By id: 'id=&amp;lt;id&amp;gt;'&lt;/li&gt;
	 * &lt;li&gt;By name: 'name=&amp;lt;name&amp;gt;'&lt;/li&gt;
	 * &lt;li&gt;By css selector: 'css=#&amp;lt;id&amp;gt;'&lt;/li&gt;
	 * &lt;li&gt;By link text selector: 'link=#&amp;lt;linktext&amp;gt;'&lt;/li&gt;
	 * &lt;li&gt;By xpath selector: 'div[@id=&amp;lt;id&amp;gt;]'&lt;/li&gt;
	 * &lt;/ul&gt;
	 * Just like SeleniumIDE, attribute name is parsed from selector when element locator is followed by an @ sign and then the name of the attribute. For Example:
	 * &lt;ul&gt;
	 * &lt;li&gt;'id=&amp;lt;id&amp;gt;@&amp;lt;attributeName&amp;gt;'&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @param locator to be parsed
	 * @return parsedLocator instance of {@link Triple}, containing {@link By} selector, attribute name and value to check
	 */
	private Triple&lt;By, String, String&gt; parse(String locator) {
<span class="fc" id="L163">		String selector = this.fitnesseMarkup.clean(locator);</span>
<span class="fc" id="L164">		String valueToCheck = StringUtils.substringAfterLast(locator, FitnesseMarkup.SELECTOR_VALUE_SEPARATOR);</span>
<span class="fc" id="L165">		String attribute = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(selector, FitnesseMarkup.SELECTOR_ATTRIBUTE_SEPARATOR), FitnesseMarkup.SELECTOR_VALUE_SEPARATOR);</span>
<span class="fc" id="L166">		boolean emptyAttribute = true;</span>
<span class="fc bfc" id="L167" title="All 4 branches covered.">		if (emptyAttribute = !StringUtils.isAlphanumeric(attribute)) {</span>
<span class="fc" id="L168">			attribute = null;</span>
		}
<span class="fc" id="L170">		By by = parseBy(selector, emptyAttribute);</span>
<span class="fc" id="L171">		return Triple.of(by, attribute, valueToCheck);</span>
	}

	private By parseBy(String selector, boolean emptyAttribute) {
<span class="fc bfc" id="L175" title="All 2 branches covered.">		String cleanedSelector = StringUtils.substringBeforeLast(selector, emptyAttribute ? FitnesseMarkup.SELECTOR_VALUE_SEPARATOR : FitnesseMarkup.SELECTOR_ATTRIBUTE_SEPARATOR);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (StringUtils.isBlank(cleanedSelector)) {</span>
<span class="fc" id="L177">			return null;</span>
		}
<span class="fc" id="L179">		String selectorPrefix = StringUtils.substringBefore(cleanedSelector, SeleniumElementFinder.SELECTOR_TYPE_SEPARATOR);</span>
<span class="fc" id="L180">		SelectorType selectorType = EnumUtils.getEnum(SelectorType.class, selectorPrefix);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		if (selectorType == null) {</span>
<span class="fc" id="L182">			selectorType = SelectorType.xpath;</span>
		}
		try {
<span class="fc" id="L185">			return selectorType.byClass.getConstructor(String.class).newInstance(StringUtils.removeStart(cleanedSelector, selectorType + SeleniumElementFinder.SELECTOR_TYPE_SEPARATOR));</span>
<span class="nc" id="L186">		} catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L187">			throw new IllegalStateException(&quot;Unexpected failure instantiating selector: &quot; + selectorPrefix, e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>